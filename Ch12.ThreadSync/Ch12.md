# Ch12 线程同步

## 12.1 为什么需要线程同步

线程同步是为了对共享资源的访问进行保护。

保护的目的是为了解决数据一致性的问题。

出现数据一致性问题其本质在于进程中的多个线程对共享资源的并发访问（同时访问）。

通过12.1.1可见，两个线程同时访问一个全局变量时，可能出现竞争的情况，导致出现数据不一致现象，需要通过Linux的线程同步技术来解决：互斥锁、条件变量、自旋锁、读写锁。

## 12.2 互斥锁（mutex）

在访问共享资源之前对互斥锁进行上锁，在访问完成后释放互斥锁（解锁）；对互斥锁进行上锁之后，任何其它试图再次对互斥锁进行加锁的线程都会被阻塞，直到当前线程释放互斥锁。

在我们的程序设计当中，只有将所有线程访问共享资源都设计成相同的数据访问规则，互斥锁才能正常工作。

### 12.2.1 互斥锁的初始化

有两种方法：
    1. 使用 PTHREAD_MUTEX_INITIALIZER 宏初始化互斥锁。
    2. 使用 pthread_mutex_init()函数初始化互斥锁。

#### 1. 使用 PTHREAD_MUTEX_INITIALIZER 宏初始化互斥锁

``` c
#define PTHREAD_MUTEX_INITIALIZER {{0, 0, 0, 0, 0, __PTHREAD_SPINS, {0, 0}}}    // 宏定义
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;  // 如何用宏初始化
```

pthread_mutex_t 其实是一个结构体类型，而宏 PTHREAD_MUTEX_INITIALIZER 其实是一个对结构体赋值操作的封装。

#### 2. 使用 pthread_mutex_init()函数初始化互斥锁

函数原型：

``` c
#include <pthread.h>
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
```

mutex 是指向需要进行初始化操作的互斥锁对象的指针。

attr 是指向【用于定义互斥锁的属性】类型对象的指针。

使用示例：

``` c
// 栈区数据
pthread_mutex_t mutex;
pthread_mutex_init(&mutex, NULL);

// 堆区数据
pthread_mutex_t *mutex = malloc(sizeof(pthread_mutex_t));
pthread_mutex_init(mutex, NULL);
```

### 12.2.2 互斥锁的上锁 & 解锁

互斥锁初始化之后，处于一个未锁定状态，通过下列函数进行上锁和解锁。

``` c
#include <pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
```

成功返回0，失败返回错误码。

锁定了已被其他线程锁定的互斥锁：阻塞，直到被原线程解锁后，才能再次上锁。

解锁一个本来没被上锁的互斥锁：错误。

解锁一个被别的线程上锁的互斥锁：错误。

### 12.2.3 pthread_mutex_trylock函数

### 12.2.4 销毁互斥锁

### 12.2.5 互斥锁死锁

### 12.2.6 互斥锁的属性

## 12.3 条件变量

## 12.4 自旋锁

## 12.5 读写锁

## 12.6 总结

## 12.7 练习