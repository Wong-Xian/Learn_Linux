# Ch13 高级IO

本章讨论IO的高级用法。

## 13.1 非阻塞IO

1. 阻塞式IO 和 非阻塞式IO
   1. 阻塞式IO：当IO缓冲区为空或其他情况，不能正常读或写时，产生阻塞，交出CPU控制权，等待有数据时再开始读或写。
   2. 非阻塞式IO：当IO缓冲区为空或其他情况，不能正常读或写时，立即返回错误码。
2. 例子：
   1. 普通文件：非阻塞式IO。
   2. 管道文件、设备文件：可以阻塞式IO，也可以非阻塞式IO。

### 13.1.1 阻塞IO与非阻塞IO读文件

1. 本小节作用：演示【阻塞】与【非阻塞】IO读取文件的区别。
2. 说明：在调用 open()函数打开文件时，为参数 flags 指定 O_NONBLOCK 标志，open()调用成功后，后续的 I/O 操作将以非阻塞式方式进行；这就是非阻塞 I/O 的打开方式，如果未指定 O_NONBLOCK 标志，则默认使用阻塞式 I/O 进行操作。

### 13.1.2 阻塞IO的优缺点

阻塞式 I/O 的优点在于能够提升 CPU 的处理效率，当自身条件不满足时，进入阻塞状态，交出 CPU资源，将 CPU 资源让给别人使用。

非阻塞式则是抓紧利用 CPU 资源，譬如不断地去轮训，这样就会导致该程序占用了非常高的 CPU 使用率。

### 13.1.3 使用非阻塞IO实现并发读取

例程描述：用非阻塞式IO读取【鼠标】和【键盘】文件数据。若代码实现中，先读取鼠标，再读取键盘，当鼠标不动时，程序将一直等待鼠标状态发生改变，此时若在键盘输入，将无法被读取。

存在的问题：这就是阻塞式 I/O 的一个困境，无法实现并发读取（同时读取），主要原因在于阻塞。

解决方法：通过轮训方式，循环，非阻塞读取鼠标和键盘的数据。
1. 读取鼠标：通过在open函数的flag中添加O_NONBLOCK标志，变成非阻塞式IO。
2. 读取键盘（标准输入）：通过fcntl函数将标准输入设置为非阻塞式。

```c
int flag;

flag = fcntl(0, F_GETFL);   //先获取原来的 flag
flag |= O_NONBLOCK;         //将 O_NONBLOCK 标志添加到 flag
fcntl(0, F_SETFL, flag);    //重新设置 flag
```

上述解决方法存在的问题：CPU占用过大！

## 13.2 IO多路复用

## 13.3 异步IO

## 13.4 优化异步IO

## 13.5 存储映射IO

## 13.6 文件锁

## 13.7 小结