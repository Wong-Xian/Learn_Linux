# Ch13 高级IO

本章讨论IO的高级用法。

## 13.1 非阻塞IO

1. 阻塞式IO 和 非阻塞式IO
   1. 阻塞式IO：当IO缓冲区为空或其他情况，不能正常读或写时，产生阻塞，交出CPU控制权，等待有数据时再开始读或写。
   2. 非阻塞式IO：当IO缓冲区为空或其他情况，不能正常读或写时，立即返回错误码。
2. 例子：
   1. 普通文件：非阻塞式IO。
   2. 管道文件、设备文件：可以阻塞式IO，也可以非阻塞式IO。

### 13.1.1 阻塞IO与非阻塞IO读文件

1. 本小节作用：演示【阻塞】与【非阻塞】IO读取文件的区别。
2. 说明：在调用 open()函数打开文件时，为参数 flags 指定 O_NONBLOCK 标志，open()调用成功后，后续的 I/O 操作将以非阻塞式方式进行；这就是非阻塞 I/O 的打开方式，如果未指定 O_NONBLOCK 标志，则默认使用阻塞式 I/O 进行操作。

### 13.1.2 阻塞IO的优缺点

阻塞式 I/O 的优点在于能够提升 CPU 的处理效率，当自身条件不满足时，进入阻塞状态，交出 CPU资源，将 CPU 资源让给别人使用。

非阻塞式则是抓紧利用 CPU 资源，譬如不断地去轮训，这样就会导致该程序占用了非常高的 CPU 使用率。

### 13.1.3 使用非阻塞IO实现并发读取

例程描述：用非阻塞式IO读取【鼠标】和【键盘】文件数据。若代码实现中，先读取鼠标，再读取键盘，当鼠标不动时，程序将一直等待鼠标状态发生改变，此时若在键盘输入，将无法被读取。

存在的问题：这就是阻塞式 I/O 的一个困境，无法实现并发读取（同时读取），主要原因在于阻塞。

解决方法：通过轮训方式，循环，非阻塞读取鼠标和键盘的数据。
1. 读取鼠标：通过在open函数的flag中添加O_NONBLOCK标志，变成非阻塞式IO。
2. 读取键盘（标准输入）：通过fcntl函数将标准输入设置为非阻塞式。

```c
int flag;

flag = fcntl(0, F_GETFL);   //先获取原来的 flag
flag |= O_NONBLOCK;         //将 O_NONBLOCK 标志添加到 flag
fcntl(0, F_SETFL, flag);    //重新设置 flag
```

上述解决方法存在的问题：CPU占用过大！

## 13.2 IO多路复用

用于解决上述通过轮训方式同时访问鼠标和键盘时，CPU占用大的问题。

### 13.2.1 何为IO多路复用

I/O 多路复用（IO multiplexing）它通过一种机制，可以监视多个文件描述符，一旦某个文件描述符（也就是某个文件）可以执行 I/O 操作时，能够通知应用程序进行相应的读写操作。

常用于：并发、非阻塞式IO

学习两个系统调用来执行IO多路复用。

### 13.2.2 select()函数介绍

系统调用 select()可用于执行 I/O 多路复用操作，调用 select()会一直阻塞，直到某一个或多个文件描述符成为就绪态（可以读或写）。

函数原型：

``` c
#include <sys/select.h>
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

- select()函数的第一个参数 nfds 通常表示最大文件描述符编号值加 1。（不太懂为什么要这么弄）
- fd_set 数据类型是一个文件描述符的集合体。
  - readfds 是用来监测文件是否可【读】的文件描述符集合。
  - writefds 是用来监测文件是否可【写】的文件描述符集合。
  - exceptfds 是用来监测【异常情况是否发生】的文件描述符集合。
- select()函数的最后一个参数 timeout 可用于设定 select()阻塞的时间上限。

文件描述符集合的所有操作都可以通过 FD_CLR()、FD_ISSET()、FD_SET()、FD_ZERO() 这四个宏来完成，这些宏定义如下所示：

``` c
#include <sys/select.h>
void FD_CLR(int fd, fd_set *set);   // 将文件描述符 fd 从参数 set 所指向的集合中移除
int FD_ISSET(int fd, fd_set *set);  // 文件描述符 fd 是参数 set 所指向的集合中的成员，返回true，否则返回false
void FD_SET(int fd, fd_set *set);   // 将文件描述符 fd 添加到参数 set 所指向的集合中
void FD_ZERO(fd_set *set);          // 将参数 set 所指向的集合初始化为空
```

select() 函数结束阻塞，返回的条件：
- readfds、writefds 或 exceptfds 指定的文件描述符中至少有一个称为就绪态
- 该调用被信号处理函数中断
- 参数 timeout 中指定的时间上限已经超时

所以，当 select() 函数返回时，readfds、writefds、exceptfds 这些集合，包含的就是已处于就绪态的文件描述符集合了。

返回值：
- -1：表示有错误发生，并且会设置errno。
- 0：表示在任何文件描述符成为就绪态之前，select调用已经超时。
- 正整数：有一个或多个文件描述符达到就绪态。

### 13.2.3 poll()函数介绍

在 poll()函数中，需要构造一个 struct pollfd 类型的数组，每个数组元素指定一个文件描述符以及我们对该文件描述符所关心的条件。

struct pollfd 结构体如下：
``` c
struct pollfd {
   int fd;          /* file descriptor */
   short events;    /* requested events */
   short revents;   /* returned events */
};
```

events 和 revents 都是位掩码，调用者初始化 events 来指定需要为文件描述符 fd 做检查的事件。

当 poll()函数返回时，revents 变量由 poll()函数内部进行设置，用于说明文件描述符 fd 发生了哪些事件（注意，poll()没有更改 events 变量），我们可以对 revents 进行检查，判断文件描述符 fd 发生了什么事件。

poll()函数原型如下所示：

``` c
#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

fds 指向struct pollfd 类型数组。

nfds 指定 fds 数组中元素的个数。

timeout 决定函数的阻塞行为，类似 select 函数的 timeout 参数。
   - timeout = -1 一直阻塞
   - timeout = 0 执行一次检查文件描述符是否处于就绪态。
   - timeout > 0 设置阻塞等待时间（单位：毫秒）

返回值：
   - -1 有错误，设置errno
   - 0 超时，未出现就绪态
   - 正整数 fds 数组中返回的 revents 变量不为 0 的 struct pollfd 对象的数量。

## 13.3 异步IO

## 13.4 优化异步IO

## 13.5 存储映射IO

## 13.6 文件锁

## 13.7 小结