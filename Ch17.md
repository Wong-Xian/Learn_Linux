# Ch17 输入设备应用编程

## 17.1 输入类设备编程介绍

### 17.1.1 什么是输入设备

鼠标、键盘、触摸屏、遥控器、画图板等。用户通过输入设备与系统交互。

### 17.1.2 input 子系统

Linux 通过 input 子系统统一管理输入设备上报的不同数据类型。

驱动开发人员基于 input 子系统开发输入设备的驱动程序，input 子系统可以屏蔽硬件的差异，向应用层提供一套统一的接口。

基于 input 子系统注册成功的输入设备，都会在/dev/input 目录下生成对应的设备节点（设备文件），设备节点名称通常为 eventX（X 表示一个数字编号 0、1、2、3 等），

### 17.1.3 读取数据的流程

1. 打开设备文件
2. 发起读数据请求（如read函数），能读就读，不能读就阻塞
3. 设备文件更新，则阻塞被打断，可读数据
4. 对读取到的数据进行解析

### 17.1.4 应用程序解析数据的流程

每一次 read 操作获取的都是一个 struct input_event 结构体类型数据，该结构体定义在<linux/input.h>头文件中。

input_event 结构体
``` c
struct input_event {
 struct timeval time;
 __u16 type;
 __u16 code;
 __s32 value;
};
```

## 17.2 读取 struct input_event 数据

``` c
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <linux/input.h>

int main(int argc, char *argv[])
{
 struct input_event in_ev = {0};
 int fd = -1;
 /* 校验传参 */
 if (2 != argc)
 {
 fprintf(stderr, "usage: %s <input-dev>\n", argv[0]);
 exit(-1);
 }
 /* 打开文件 */
 if (0 > (fd = open(argv[1], O_RDONLY))) {
 perror("open error");
 exit(-1);
 }
 for ( ; ; )
 {
 /* 循环读取数据 */
 if (sizeof(struct input_event) !=
 read(fd, &in_ev, sizeof(struct input_event))) {
 perror("read error");
 exit(-1);
 }
 printf("type:%d code:%d value:%d\n",
 in_ev.type, in_ev.code, in_ev.value);
 }
}

```


## 17.3 在开发板上验证

## 17.4 按键应用编程

## 17.5 触摸屏应用编程

## 17.6 鼠标应用编程
