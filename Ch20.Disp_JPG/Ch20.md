# 第十二章 在LCD上显示JPEG图片

## 20.1 JPEG 简介

是一个图象压缩标准。

有损压缩，但压缩的部分（高频分量）人眼不易察觉，

## 20.2 libjpeg 简介

JPEG 压缩标准使用了一套压缩算法对原始图像数据进行了压缩得到.jpg 或.jpeg 图像文件，如果想要在 LCD 上显示.jpg 或.jpeg 图像文件，则需要对其进行解压缩、以得到图像的原始数据，譬如 RGB 数据。

libjpeg 是一个完全用 C 语言编写的函数库，包含了 JPEG 解码（解压缩）、JPEG 编码（创建压缩）和 其他的 JPEG 功能的实现。可以使用 libjpeg 库对.jpg 或.jpeg 压缩文件进行解压或者生成.jpg 或.jpeg 压缩文件。

## 20.3 libjpeg 移植

### 20.3.1 下载源码包

### 20.3.2 编译源码

### 20.3.3 安装目录下的文件夹介绍

### 20.3.4 移植到开发板

我倒要看看如何把安装在Ubuntu上的库移植到开发板上的Linux系统中。

哦，就是简单的复制过去而已啊。

## 20.4 libjpeg 使用说明

解码过程：
1. 创建jpeg解码对象
2. 指定解码数据源
3. 读取图像信息
4. 设置解码参数
5. 开始解码
6. 读取解码后数据
7. 解码结束
8. 销毁/释放解码对象

jpeg_decompress_struct 保存jpeg信息的结构体（最重要）
jpeg_error_mgr 错误处理结构体

``` c
struct jpeg_decompress_struct cinfo;
struct jpeg_error_mgr jerr;
```

### 20.4.1 错误处理

``` c
/* Error handler object */
struct jpeg_error_mgr {
    /* Error exit handler: does not return to caller */
    JMETHOD(noreturn_t, error_exit, (j_common_ptr cinfo));
    
    /* Conditionally emit a trace or warning message */
    JMETHOD(void, emit_message, (j_common_ptr cinfo, int msg_level));
    
    /* Routine that actually outputs a trace or error message */
    JMETHOD(void, output_message, (j_common_ptr cinfo));
    
    /* Format a message string for the most recent JPEG error or message */
    JMETHOD(void, format_message, (j_common_ptr cinfo, char * buffer));

#define JMSG_LENGTH_MAX 200 /* recommended size of format_message buffer */
    
    /* Reset error state variables at start of a new image */
    JMETHOD(void, reset_error_mgr, (j_common_ptr cinfo));

    /* The message ID code and any parameters are saved here.
    * A message can have one string parameter or up to 8 int parameters.
    */
    int msg_code;

#define JMSG_STR_PARM_MAX 80

    union {
        int i[8];
        char s[JMSG_STR_PARM_MAX];
    } msg_parm;
    
    /* Standard state variables for error facility */
    int trace_level; /* max msg_level that will be displayed */
    /* For recoverable corrupt-data errors, we emit a warning message,
    * but keep going unless emit_message chooses to abort. emit_message
    * should count warnings in num_warnings. The surrounding application
    * can check for bad data by seeing if num_warnings is nonzero at the
    * end of processing.
    */

    long num_warnings; /* number of corrupt-data warnings */
    /* These fields point to the table(s) of error message strings.
    * An application can change the table pointer to switch to a different
    * message list (typically, to change the language in which errors are
    * reported). Some applications may wish to add additional error codes
    * that will be handled by the JPEG library error mechanism; the second
    * table pointer is used for this purpose.
    *
    * First table includes all errors generated by JPEG library itself.
    * Error code 0 is reserved for a "no such error string" message.
    */

    const char * const * jpeg_message_table; /* Library errors */
    int last_jpeg_message; /* Table contains strings 0..last_jpeg_message */
    /* Second table can be added by application (see cjpeg/djpeg for example).
    * It contains strings numbered first_addon_message..last_addon_message.
    */
    const char * const * addon_message_table; /* Non-library errors */
    int first_addon_message; /* code for first string in addon table */
    int last_addon_message; /* code for last string in addon table */
};
```

如何使用：
``` c
//初始化错误处理对象、并将其与解压对象绑定
cinfo.err = jpeg_std_error(&jerr);
```

### 20.4.2 创建解码对象

使用方法：
``` c
jpeg_create_decompress(&cinfo);
```

### 20.4.3 设置数据源

设置方法：
``` c
FILE *jpeg_file = NULL; // 定义文件指针
jpeg_file = fopen("./image.jpg", "r"); // 只读方式打开
if (NULL == jpeg_file)  // 差错控制
{
    perror("fopen error");
    return -1;
}
jpeg_stdio_src(&cinfo, jpeg_file);//指定图像文件
```

### 20.4.4 读取 JPEG 文件的头信息

``` c
jpeg_read_header(&cinfo, TRUE);
```

调用 jpeg_read_header()后，可以得到 jpeg 图像的一些信息，譬如 jpeg 图像的宽度、高度、颜色通道数以及 colorspace 等，这些信息会赋值给 cinfo 对象中的相应成员变量。

### 20.4.5 设置解码处理参数

直接对 cinfo 对象的成员变量进行修改即可。

示例：
- 输出的颜色（cinfo.out_color_space）：默认配置为 RGB 颜色，也就是 JCS_RGB；
- 图像缩放操作（cinfo.scale_num 和 cinfo.scale_denom）：使用 scale_num 和 scale_denom 两个参数，解出来的图像大小就是 scale_num/scale_denom。

### 20.4.6 开始解码

操作：
``` c
jpeg_start_decompress(&cinfo);
```

在完成解压缩操作后，会将解压后的图像信息填充至 cinfo 结构中。

### 20.4.7 读取数据

解码后的数据按照从左到右、从上到下的顺序存储，每个像素点对应的各颜色或灰度通道数据依次存储。

``` c
jpeg_read_scanlines(&cinfo, &buf, 1);   // 该函数目前只支持读1行，第三个参数是1
```

我们可以通过下面这种循环方式依次读取解码后的所有数据：
``` c
while(cinfo.output_scanline < cinfo.output_height)
{ 
    jpeg_read_scanlines(&cinfo, buffer, 1);
    //do something 
}
```

### 20.4.8 结束解码

``` c
jpeg_finish_decompress(&cinfo);
```

### 20.4.9 释放/销毁解码对象

``` c
jpeg_destroy_decompress(&cinfo);
```

## 20.5 libjpeg 应用编程

## 20.6 Sum