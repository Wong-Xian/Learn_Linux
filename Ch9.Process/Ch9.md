# CH9 进程

## 9.1 进程 与 程序

### 9.1.1 main()函数由谁调用

运行 main()函数之前需要先执行一段引导代码，最终由这段引导代码去调用应用程序的 main()函数。

程序运行需要通过操作系统的加载器来实现，加载器是操作系统中的程序，当执行程序时，加载器负责将此应用程序加载内存中去执行。

执行带参数的main函数：命令行参数（command-line argument）由 shell 进程逐一进行解析，shell 进程会将这些参数传递给加载器，加载器加载应用程序时会将其传递给应用程序引导代码，当引导程序调用 main()函数时，在由它最终传递给 main()函数。

### 9.1.2 程序如何结束

1. 正常终止
    1. return
    2. C库函数exit()
    3. 系统调用_exit(),_Exit()
2. 异常终止
    1. abort()函数
    2. 收到信号，如SIGKILL

atexit()库函数用于注册一个进程在正常终止时要调用的函数。

函数原型：

``` c
#include <stdlib.h>
int atexit(void (*function)(void));
```

### 9.1.3 何为进程

进程其实就是一个可执行程序的实例。

可执行程序的实例就是可执行文件被运行。

进程是一个动态过程，而非静态文件，它是程序的一次运行过程，当应用程序被加载到内存中运行之后它就称为了一个进程，当程序运行结束后也就意味着进程终止，这就是进程的一个生命周期。

### 9.1.4 进程号

PID 唯一标识进程 是一个正数

<b>系统调用</b>getpid()函数用于获取当前进程的PID

原型：

``` c
#include <sys/types.h>
#include <unistd.h>
pid_t getpid(void);
```

<b>系统调用</b>getppid()函数用于获取父进程的PID

原型：

``` c
#include <sys/types.h>
#include <unistd.h>
pid_t getppid(void);
```

## 9.2 进程的环境变量

在终端通过env查询

### 9.2.1 应用程序中获取环境变量

进程的环境变量是从其父进程中继承过来的。

环境变量的字符信息存放在字符串数组中，全局变量environ变量指向环境变量。

``` c
extern char **environ;
```

获取指定环境变量，用C库函数，getenv()函数

### 9.2.2 添加/删除/修改 环境变量

1. putenv()

``` c
#include <stdlib.h>
int putenv(char *string);
```

string不能是栈中分配的数组，即需要用户手动开辟内存空间。

2. setenv()

``` c
#include <stdlib.h>
int setenv(const char *name, const char *value, int overwrite);
```

3. unsetenv()

``` c
#include <stdlib.h>
int unsetenv(const char *name);
```

### 9.2.3 清空环境变量

``` c
#include <stdlib.h>
int clearenv(void);
```

### 9.2.4 环境变量的作用

告诉机器，你输入的命令到哪里去执行。指定命令执行的路径。

## 9.3 进程的内存布局

C程序的组成部分：
1. 正文段，代码段
2. 初始化数据段
3. 未初始化数据段（bss）
4. 栈
   1. 程序的局部变量
   2. 函数调用时保存的信息
5. 堆

## 9.4 进程的虚拟地址空间

每个进程都在自己独立的地址空间运行。

32位系统中，每个进程的地址空间为4GB，其中用户独享3GB，内核独享1GB。

硬件MMU将虚拟地址和物理地址形成映射关系。

引入虚拟内存解决物理上内存隔离的问题，不用考虑链接地址和运行地址不统一的问题

## 9.5 fork()创建子进程

``` c
#include <unistd.h>
pid_t fork(void);
```

调用后产生子进程，其与父进程之间的关系，共用代码段，但不共用数据段、堆、栈等。

## 9.6 父、子进程之间的文件共享

## 9.7 系统调用vfork()

## 9.8 fork()之后的竞争条件

## 9.9 进程的诞生与终止

## 9.10 监视子进程

## 9.11 执行新程序

## 9.12 进程状态与进程关系

## 9.13 守护进程

## 9.14 单例模式运行