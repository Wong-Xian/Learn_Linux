# 5.5 文件访问权限

所有文件类型（目录、设备文件）都有访问权限（access permission），不只有普通文件有访问权限。

## 5.5.1 【普通权限】和【特殊权限】

文件权限可分为两大类：
* 普通权限：包括对文件的读、写、执行。
* 特殊权限：包括对文件的附加权限，如set user id和set group id等。

### 普通权限

每个文件都有9个访问权限位，可分为3类
* 文件所有者
    * 读权限
    * 写权限
    * 执行权限
* 同组用户
    * 读权限
    * 写权限
    * 执行权限
* 其他用户
    * 读权限
    * 写权限
    * 执行权限

当进程每次对文件进行读、写、执行等操作时，内核就会对文件进行访问权限检查，以确定该进程对文件是否拥有相应的权限。

首先要搞清楚该进程对于需要进行操作的文件来说是属于哪一类“角色”：
* 如果<b>【进程的有效用户ID】</b>等于<b>【文件所有者ID】</b>，意味着该进程以文件所有者的角色存在。
* 如果<b>【进程的有效用户ID】</b>并不等于<b>【文件所有者ID】</b>，意味着该进程并不是文件所有者身份；但是<b>【进程的有效用户组ID】</b>或<b>【进程的附属组ID】</b>之一等于<b>【文件的组ID】</b>，那么意味着该进程以文件所属组成员的角色存在，也就是文件所属组的同组用户成员。
* 如果<b>【进程的有效用户ID】</b>不等于<b>【文件所有者ID】</b>、并且<b>【进程的有效用户组ID】</b>或<b>【进程的所有附属组ID】</b>均不等于<b>【文件的组ID】</b>，那么意味着该进程以其它用户的角色存在。
* 如果<b>【进程的有效用户ID】</b>等于0（root 用户），则无需进行权限检查，直接对该文件拥有最高权限。

### 特殊权限

st_mode字段中除了记录文件的9个普通权限之外，还记录了文件的3个特殊权限。

S 字段三个 bit 位中，从高位到低位依次表示文件的：

* set-user-ID 位权限
* set-group-ID 位权限
* sticky 位权限

这三种权限分别使用 S_ISUID、S_ISGID 和 S_ISVTX 三个宏来表示：
``` 
S_ISUID 100 000 000 000 set-user-ID bit
S_ISGID 010 000 000 000 set-group-ID bit
S_ISVTX 001 000 000 000 sticky bit
```

* 当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-user-ID 位权限被设置，内核会将进程的有效 ID 设置为该文件的用户 ID（文件所有者 ID），意味着该进程直接获取了文件所有者的权限、以文件所有者的身份操作该文件。
* 当进程对文件进行操作的时候、将进行权限检查，如果文件的 set-group-ID 位权限被设置，内核会将进程的有效用户组 ID 设置为该文件的用户组 ID（文件所属组 ID），意味着该进程直接获取了文件所属组成员的权限、以文件所属组成员的身份操作该文件。
* Sticky 位权限：略

## 5.5.2 目录权限

前面我们一直谈论的都是文件的读、写、执行权限，那对于创建文件、删除文件等这些操作难道就不需要相应的权限了吗？事实并不如此。删除文件、创建文件这些操作也是需要相应权限的，那这些权限又是从哪里获取的呢？答案就是目录。

目录（文件夹）在 Linux 系统下也是一种文件，拥有与普通文件相同的权限方案（S/U/G/O），只是这些权限的含义另有所指：

* 目录的读权限：可列出（譬如：通过 ls 命令）目录之下的内容（即目录下有哪些文件）。
* 目录的写权限：可以在目录下创建文件、删除文件。
* 目录的执行权限：可访问目录下的文件，譬如对目录下的文件进行读、写、执行等操作。

<b><font size=5>Sum:</font></b>

* 要想访问目录下的文件，譬如查看文件的 inode 节点、大小、权限等信息，还需要对目录拥有执行权限。
* 若拥有对目录的执行权限、而无读权限，只要知道目录内文件的名称，仍可对其进行访问，但不能列出目录下的内容（即目录下包含的其它文件的名称）。
* 要想在目录下创建文件或删除原有文件，需要同时拥有对该目录的执行和写权限。
* 如果需要对文件进行读、写或执行等操作，不光是需要拥有该文件本身的读、写或执行权限，还需要拥有文件所在目录的执行权限。

## 5.5.3 检查文件权限access

程序当中对文件进行相关操作之前，需要先检查执行进程的用户是否对该文件拥有相应的权限。

方法：access【系统调用】，函数原型如下：

``` c
#include <unistd.h>

int access(const char *pathname, int mode);
```

<b>mode</b>可取以下值：（可通过按位或运算符组合使用）

* F_OK：检查文件是否存在
* R_OK：检查是否拥有读权限
* W_OK：检查是否拥有写权限
* X_OK：检查是否拥有执行权限

<b>返回值：</b>检查项通过则返回 0，表示拥有相应的权限并且文件存在；否则返回-1，如果多个检查项组合在一起，只要其中任何一项不通过都会返回-1。

## 5.5.4 修改文件权限chmod

### chmod

Linux命令chmod可以修改文件的权限，底层是调用了chmod【系统调用】。

函数原型：
``` c
#include <sys/stat.h>

int chmod(const char *pathname, mode_t mode);
```

<b>mode</b>：

* S_ISUID   (04000) set user ID
* S_ISGID   (02000) set group ID
* S_ISVTX   (01000) sticky bit
---
* S_IRUSR   (00400) read by owner
* S_IWUSR   (00200) write by owner
* S_IXUSR   (00100) execute by owner
---
* S_IRGRP   (00040) read by group
* S_IWGRP   (00020) write by group
* S_IXGRP   (00010) execute by group
---
* S_IROTH   (00004) read by others
* S_IWOTH   (00002) write by others
* S_IXOTH   (00001) execute by others

可以直接使用八进制数据来描述

<b>返回值：</b>成功返回 0；失败返回-1，并设置 errno。

### fchmod

fchmod()与 chmod()的区别在于使用了文件描述符来代替文件路径。

``` c
#include <sys/stat.h>

int fchmod(int fd, mode_t mode);
```

## 5.5.5 umask函数

是Linux下的一个命令。umask命令用于查看/设置权限掩码，权限掩码主要用于对新建文件的权限进行屏蔽。
查看/设置时需要去除特殊权限位，umask不能对特殊权限位进行屏蔽。

当新建文件时，文件实际的权限并不等于我们所设置的权限，譬如：调用 open 函数新建文件时，文件实际的权限并不等于 mode 参数所描述的权限，而是通过如下关系得到实际权限：（mode值与umask值取反后按位相与）

```
mode & ~umask
```

umask 权限掩码是进程的一种属性，用于指明该进程新建文件或目录时，应屏蔽哪些权限位。

进程的umask 通常继承至其父进程（关于父、子进程相关的内容将会在后面章节给大家介绍），譬如在 Ubuntu shell终端下执行的应用程序，它的 umask 继承至该 shell 进程。

<b>linux系统调用</b>函数umask的函数原型：
``` c
#include <sys/types.h>
#include <sys/stat.h>

mode_t umask(mode_t mask);
```

<b>返回值：</b>返回设置之前的 umask 值，也就是旧的 umask。